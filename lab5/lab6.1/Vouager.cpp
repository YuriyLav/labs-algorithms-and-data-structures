#include <iostream>
#include <fstream>
using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    const int n = 5;     //переменная для хранения числа вершин графа
    int a[n][n], b[n][n];         //матрица смежности графа
    int i, j, c, i2, j2, //переменные-итераторы, которые используются в циклах
        i3, j3;          //индексы нуля с максимальной функцией штрафа
    int min,             //переменная для поиска минимума в строке\столбце
        min_i_shtraf,    //переменная для хранения минимального значения в столбце для функции штрафа
        min_j_shtraf,    //переменная для хранения минимального значения в строке для функции штрафа
        max_f_shtraf,    //переменная для хранения значения максимальной функции штрафа
        total_weight = 0;//переменная для хранения веса

    //считывание данных матрицы из файла
    ifstream fin("matrix.txt");
    for (i = 0; i < n; i++) for (j = 0; j < n; j++) {
        fin >> a[i][j];  //считываем данные элементов
        b[i][j] = a[i][j]; //дублируем матрицу для подсчёта конечного веса
    }
    fin.close();

    for (i = 0; i < n; i++)
        a[i][i] = -1;                          //устанавливаем неопределённые значения для диагонали
    a[0][4] = -1; //удаление ребер (1,5) и (2, 1)
    a[1][0] = -1;

    for (c = 0; c < n; c++) {
        //приводим матрицу к виду, когда в каждой строке и каждом столбце есть 0
        for (i = 0; i < n; i++)                                          //пробег по всем строкам
        {
            min = INT_MAX;                                             //изначально минимальное - самое большое число
            for (j = 0; j < n; j++) {
                if ((a[i][j] >= 0) && (a[i][j] < min)) min = a[i][j];  //находим минимальный элемент строки
            }
            for (j = 0; j < n; j++) if (a[i][j] >= 0) {
                a[i][j] -= min;                                        //вычитаем минимальный элемент из каждого элемента строки кроме диагонали 
            }
        }
        for (j = 0; j < n; j++)                                          //пробег по всем столбцам
        {
            min = INT_MAX;                                             //изначально минимальное - самое большое число
            for (i = 0; i < n; i++) {
                if ((a[i][j] >= 0) && (a[i][j] < min)) min = a[i][j];  //находим минимальный элемент столбца
            }
            for (i = 0; i < n; i++) if (a[i][j] >= 0) {
                a[i][j] -= min;                                        //вычитаем минимальный элемент из каждого элемента столбца кроме диагонали
            }
        }

        //поиск максимальной фунции штрафа
        max_f_shtraf = -1;
        for (i = 0; i < n; i++)
            for (j = 0; j < n; j++)
                if (a[i][j] == 0) {          //определяем нулевой элемент и его индексы
                    min_i_shtraf = INT_MAX;  //изначально минимальным элементам задаём максимальное значение
                    min_j_shtraf = INT_MAX;

                    for (j2 = 0; j2 < n; j2++) //поиск минимального элемента для функции штрафа в строке с нулём
                        if ((a[i][j2] >= 0) && (j2 != j) && (a[i][j2] < min_j_shtraf)) //элемент >=0; это не 0, для которого считаем функцию штрафа; 
                            min_j_shtraf = a[i][j2];                                    //элемент меньше текущего мин.значения функции штрафа

                    for (i2 = 0; i2 < n; i2++) //поиск минимального элемента для функции штрафа в столбце с нулём
                        if ((a[i2][j] >= 0) && (i2 != i) && (a[i2][j] < min_i_shtraf)) //элемент >=0; это не 0, для которого считаем функцию штрафа;
                            min_i_shtraf = a[i2][j];  
                                  //элемент меньше текущего мин.значения функции штрафа
                    if (min_i_shtraf + min_j_shtraf > max_f_shtraf)   //нахождение максимальной функции штрафа и индексов нуля
                    {
                        max_f_shtraf = min_i_shtraf + min_j_shtraf;   //функция штрафа - сумма мин.элемента строки и мин.элемента столбца
                        i3 = i;
                        j3 = j;
                    }
                }

        //исключение досрочного завершения тура
        for (int j = 0; j < n; j++)
            if (a[i3][j] >= 0)
                a[i3][j] = -1;   //исключение строки

        for (int i = 0; i < n; i++)
            if (a[i][j3] >= 0)
                a[i][j3] = -1;   //исключение столбца 

        if (a[j3][i3] >= 0) a[j3][i3] = -1; //исключение кратного ребра

        a[i3][j3] = -2;  //помечаем элемент для восстановления пути
    }

    //вывод маршрута и его веса
    cout << "Маршрут тура:" << endl << 1;
    i2 = 0;
    for (c = 0; c < n; c++)
        for (j = 0; j < n; j++) if (a[i2][j] == -2) {  //находим помеченные элементы
            total_weight += b[i2][j];  //сумируем веса рёбер
            cout << "->" << j + 1;     //вывод маршрута
            i2 = j;
            break;
        }
    cout << "->" << 1 << endl;
    total_weight += b[i2][0];          //прибавляем последнее ребро, вовращающее нас в 1 пункт
    cout << "Вес тура:" << total_weight << endl;
    return 0;
}